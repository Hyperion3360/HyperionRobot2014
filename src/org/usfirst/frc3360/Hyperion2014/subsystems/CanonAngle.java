// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc3360.Hyperion2014.subsystems;
import edu.wpi.first.wpilibj.AnalogChannel;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.SpeedController;
import org.usfirst.frc3360.Hyperion2014.RobotMap;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc3360.Hyperion2014.Robot;
import edu.wpi.first.wpilibj.Ultrasonic;
/**
 *
 */
public class CanonAngle extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController allWheelAngleMotor = RobotMap.canonAngleAllWheelAngleMotor;
    AnalogChannel anglePot = RobotMap.canonAngleAnglePot;
    DigitalInput upperAngleLimitSwitch = RobotMap.canonAngleUpperAngleLimitSwitch;
    DigitalInput lowerAngleLimitSwitch = RobotMap.canonAngleLowerAngleLimitSwitch;
    Ultrasonic distanceUltrasonic = RobotMap.distanceUltrasonic;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    
    // values to be changed after testing
    
    final double maxCanonAngleValue = 1;
    final double minCanonAngleValue = 0;
    
    double requestedAngleValue;
    double throttleValue;
    
    
    double angleCorrection;
    
    int currentDistance;
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        
       
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    
    public void AngleStop(){
        
        // stops the canon angle motors (duh!)
        
        allWheelAngleMotor.set(0);
    }
   
    
    public void HandleManualMode(){
        
        // the throttle value is coverted to a percentage of the canon angle....
        // exemple: 0.10 value = 10% of the maximum angle 
        
        throttleValue = (2 * (Robot.oi.getCoPilotJoystick().getRawAxis(2))) -0.3;
    
        
        if(throttleValue <= 0.07)
        {
            throttleValue = 0;
        }
        
        requestedAngleValue = (maxCanonAngleValue) * throttleValue;
        
         if (requestedAngleValue > anglePot.getAverageVoltage() && anglePot.getAverageVoltage() < minCanonAngleValue){
            allWheelAngleMotor.set(1);
        }
        
        if (requestedAngleValue < anglePot.getAverageVoltage() && anglePot.getAverageVoltage() > minCanonAngleValue){
            allWheelAngleMotor.set(-1);
        }
    }
    
    public void HandleAutoMode(){
        
        // get the distance with the ultrasonic in order to set the right angle by itself
        
        currentDistance = (int)distanceUltrasonic.getRangeInches();
        
        angleCorrection = Robot.oi.getCoPilotJoystick().getRawAxis(4);
        
        //switch loop for different distances (will eventually use an algorithm after tests)
        
        switch (currentDistance){
            
            case 1:
                    {     
                requestedAngleValue = 1 + angleCorrection;
                break;
            }
            case 2:
            {
                requestedAngleValue = 2 + angleCorrection;
                break;
            }
            
            case 3:
            {
                requestedAngleValue = 3 + angleCorrection;
                break;
            }
            case 4:
            {
                requestedAngleValue = 4 + angleCorrection;
                break;
            }
            case 5:
            {
                requestedAngleValue = 5 + angleCorrection;
                break;
            }
            case 6:
            {
                requestedAngleValue = 6 + angleCorrection;
                break;
            }
            case 7:
            {
                requestedAngleValue = 7 + angleCorrection;
                break;
            }
            case 8:
            {
                requestedAngleValue = 8 + angleCorrection;
                break;
            }
            
        }
        
        // test if the canon can move, then move it (angle tolerance not added yet)
        
        if (requestedAngleValue > anglePot.getAverageVoltage() && anglePot.getAverageVoltage() < minCanonAngleValue){
            allWheelAngleMotor.set(1);
        }
        
        if (requestedAngleValue < anglePot.getAverageVoltage() && anglePot.getAverageVoltage() > minCanonAngleValue){
            allWheelAngleMotor.set(-1);
        }
    }
    
}
