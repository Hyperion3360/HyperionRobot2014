// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc3360.Hyperion2014.subsystems;

import edu.wpi.first.wpilibj.AnalogChannel;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import org.usfirst.frc3360.Hyperion2014.RobotMap;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc3360.Hyperion2014.commands.CanonAngle_HandleManualMode;

/**
 *
 */
public class CanonAngle extends PIDSubsystem {

    SpeedController allWheelAngleMotor = RobotMap.ms_scCanonAngle_AllWheel;
    AnalogChannel anglePot = RobotMap.ms_anCanonAngle;
    DigitalInput upperAngleLimitSwitch = RobotMap.ms_diCanonAngle_UpperLimit;
    DigitalInput lowerAngleLimitSwitch = RobotMap.ms_diCanonAngle_LowerLimit;

    AnalogChannel m_anFrontSonar = RobotMap.ms_anVision_FrontSonar;

    // WARNING: The logic will only work if ms_MAX_CANON_ANGLE_VALUE > ms_MIN_CANON_ANGLE_VALUE;
    public final static double ms_MAX_CANON_ANGLE_VALUE = 90;
    public final static double ms_MIN_CANON_ANGLE_VALUE = 8;

    public final static double ms_MAX_THROTTLE_VALUE = 0.55;
    public final static double ms_MIN_THROTTLE_VALUE = 2.43;

    final double ms_MAX_ANGLE_TOLERANCE = 0.025;

    final double ms_db_ANGLE_AT_90 = 4.50;
    final double ms_db_ANGLE_AT_0 = 0.35;

    double m_dbCurrentAngle;
    double m_dbRequestedAngleValue;
    double m_dbThrottleValue;

    double m_dbCurrentDistanceFeet = 0;

    double m_dbAngleCorrection;

    double m_dbAngleWanted;

    double m_dbA = -0.0002;
    double m_dbB = 0.0126;
    double m_dbC = -0.3406;
    double m_dbD = 4.6572;
    double m_dbE = -32.972;
    double m_dbF = 148.83;

    boolean m_bIsGoingDown = false;
    boolean m_bIsGoingUp = false;
    boolean m_bIsReadyToShoot = false;

    boolean m_bElevationStop = false;
    boolean m_bLoweringStop = false;

    public CanonAngle() {
        super("CanonAngle", 0.07, .0001, 0);
        getPIDController().setContinuous(false);
        getPIDController().setInputRange(ms_MIN_CANON_ANGLE_VALUE, ms_MAX_CANON_ANGLE_VALUE);
        getPIDController().setOutputRange(-1, 1);
        getPIDController().setPercentTolerance(5);
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        setDefaultCommand(new CanonAngle_HandleManualMode());
    }

    public void AngleStop() {
        allWheelAngleMotor.set(0);
    }

    public void ResetSecurity() {
        m_bElevationStop = false;
        m_bLoweringStop = false;
    }

    public void EnableAngleMode() {
        setSetpoint(getCurrentAngle());
        enable();
    }

    public void DisableAngleMode() {
        disable();
        AngleStop();
        ResetSecurity();
    }

    public void HandleAngleMode(double dbAngleDegree) {
        //System.out.println("HandleAngleMode: " + dbAngleDegree);
        setSetpoint(dbAngleDegree);
        GetSonarDistance();
    }

    private double GetSafeSpeed(double speed) {
        m_dbCurrentAngle = getCurrentAngle();
        if (isElevatingSpeed(speed)) {
            if (!m_bElevationStop) {
                if (m_dbCurrentAngle > ms_MAX_CANON_ANGLE_VALUE) {
                    //System.out.println("HandleManualMode: Maximum angle reach based on potentiometer.");
                    speed = 0;
                } else if (isUpperLimitSwitchPressed()) {
                    //System.out.println("HandleManualMode: Maximum angle reach based on limit switch.");
                    m_bElevationStop = true;
                    speed = 0;
                } else if (m_bLoweringStop) {
                    //System.out.println("HandleManualMode: Canceling lowering emergency stop.");
                    m_bLoweringStop = false;
                }
            } else {
                //System.out.println("HandleManualMode: Emergency stop for elevation activated");
                speed = 0;
            }
        } else if (isLoweringSpeed(speed)) {
            if (!m_bLoweringStop) {
                if (m_dbCurrentAngle < ms_MIN_CANON_ANGLE_VALUE) {
                    //System.out.println("HandleManualMode: Minimum angle reach based on potentiometer.");
                    speed = 0;
                } else if (isLowerLimitSwitchPressed()) {
                    //System.out.println("HandleManualMode: Minimum angle reach based on limit switch.");
                    m_bLoweringStop = true;
                    speed = 0;
                } else if (m_bElevationStop) {
                    //System.out.println("HandleManualMode: Canceling elevation emergency stop.");
                    m_bElevationStop = false;
                }
            } else {
                //System.out.println("HandleManualMode: Emergency stop for lowering activated");
                speed = 0;
            }
        } else {
            speed = 0.05;
        }
        return speed;
    }

    private boolean isUpperLimitSwitchPressed() {
        return !upperAngleLimitSwitch.get();
    }

    private boolean isLowerLimitSwitchPressed() {
        return !lowerAngleLimitSwitch.get();
    }

    public double getCurrentAngle() {
        final double dbVoltageToAngleRatio = 90 / (ms_db_ANGLE_AT_90 - ms_db_ANGLE_AT_0);
        double dbCurrentAnglePotValue = anglePot.getAverageVoltage();
        double dbCurrentAngle = dbCurrentAnglePotValue * dbVoltageToAngleRatio;

        // Automatic mode is currently disabled.
        //System.out.println("potentiometer value = " + dbCurrentAnglePotValue);
        //System.out.println("Canon angle = " + dbCurrentAngle);
        SmartDashboard.putNumber("Canon angle (degree)", dbCurrentAngle);
        return dbCurrentAngle;
    }

    private boolean isLoweringSpeed(double speed) {
        return speed < 0;
    }

    private boolean isElevatingSpeed(double speed) {
        return speed > 0;
    }

    protected double returnPIDInput() {
        return getCurrentAngle();
    }

    protected void usePIDOutput(double d) {
        //System.out.println("PID ANGLE Motor output = " + d);
        //System.out.println("Safe PID output = " + GetSafeSpeed(d));
        allWheelAngleMotor.set(GetSafeSpeed(d));
    }

    private double GetSonarDistance() {
        double dbSonarValue = m_anFrontSonar.getAverageVoltage();
        double dbCurrentDistanceFeet = dbSonarValue * 1.9672799229 - 0.1434867439;
        if (dbCurrentDistanceFeet < 0) {
            dbCurrentDistanceFeet = 0;
        }
        //System.out.print("Sonar voltage = " + dbSonarValue + ", distance= " + dbCurrentDistanceFeet);
        SmartDashboard.putNumber("Front sonar voltage", dbSonarValue);
        SmartDashboard.putNumber("Sonar measured distance", dbCurrentDistanceFeet);

        return dbCurrentDistanceFeet;
    }

    public double getPerfectAngle() {
        m_dbCurrentDistanceFeet = GetSonarDistance();
        System.out.println("Perfect angle using sonar value = " + m_dbCurrentDistanceFeet);

        //formule a modifier****
        m_dbAngleWanted = m_dbA * com.sun.squawk.util.MathUtils.pow(m_dbCurrentDistanceFeet, 5)
                + m_dbB * com.sun.squawk.util.MathUtils.pow(m_dbCurrentDistanceFeet, 4)
                + m_dbC * com.sun.squawk.util.MathUtils.pow(m_dbCurrentDistanceFeet, 3)
                + m_dbD * com.sun.squawk.util.MathUtils.pow(m_dbCurrentDistanceFeet, 2)
                + m_dbE * m_dbCurrentDistanceFeet
                + m_dbF;
        //formule a modifier****
        if (m_dbAngleWanted < 0) {
            m_dbAngleWanted = 0;
        } else if (m_dbAngleWanted > 90) {
            m_dbAngleWanted = 90;
        }

        System.out.println("Angle wanted = " + m_dbAngleWanted);
        SmartDashboard.putNumber("Angle Wanted: ", m_dbAngleWanted);

        return m_dbAngleWanted;
    }
}
