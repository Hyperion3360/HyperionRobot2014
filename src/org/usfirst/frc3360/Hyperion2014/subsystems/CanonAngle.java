// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc3360.Hyperion2014.subsystems;
import edu.wpi.first.wpilibj.AnalogChannel;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.SpeedController;
import org.usfirst.frc3360.Hyperion2014.RobotMap;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc3360.Hyperion2014.Robot;
import edu.wpi.first.wpilibj.Ultrasonic;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
/**
 *
 */
public class CanonAngle extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController allWheelAngleMotor = RobotMap.canonAngleAllWheelAngleMotor;
    AnalogChannel anglePot = RobotMap.canonAngleAnglePot;
    DigitalInput upperAngleLimitSwitch = RobotMap.canonAngleUpperAngleLimitSwitch;
    DigitalInput lowerAngleLimitSwitch = RobotMap.canonAngleLowerAngleLimitSwitch;
    AnalogChannel distanceUltrasonic = RobotMap.distanceUltrasonic;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    
    // values to be changed after testing
    
    final double maxCanonAngleValue = 4.8;
    final double minCanonAngleValue = 0.7;
    final double MaxAngleTolerance = 0.1;
    
    double desiredSpeed = 0;
    double angleDifference = 0;
    double currentAngle;
    double requestedAngleValue;
    double throttleValue;
    
    
    double angleCorrection;
    
    int currentDistance;
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        
       
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    
    public void AngleStop(){
        
        // stops the canon angle motors (duh!)
        
        allWheelAngleMotor.set(0);
    }
   
    
    public void HandleManualMode(){
        
        currentAngle = anglePot.getAverageVoltage();
        System.out.println(anglePot.getAverageVoltage() + "potentiometer value");
        // the throttle value is coverted to a percentage of the canon angle....
        // exemple: 0.10 value = 10% of the maximum angle 
        
        throttleValue = (Math.abs(Robot.oi.getCoPilotJoystick().getRawAxis(2) * 1.4925)) + 0.1194;
    
        System.out.println(throttleValue + "throttle value");
        
  /*      if(throttleValue <= 0.07)
        {
            throttleValue = 0;
        }
    */
          
        requestedAngleValue = (minCanonAngleValue + ((maxCanonAngleValue - minCanonAngleValue) * throttleValue));
        
        System.out.println("requested angle" + requestedAngleValue);
        
        
        angleDifference = requestedAngleValue - currentAngle;
        
         // First check limit switch states
        SmartDashboard.putBoolean("Upper angle limit switch", upperAngleLimitSwitch.get());
        SmartDashboard.putBoolean("Lower angle limit switch", lowerAngleLimitSwitch.get());
        
        if (!upperAngleLimitSwitch.get() && angleDifference > 0) {
            desiredSpeed = 0;
        }
        else if (!lowerAngleLimitSwitch.get() && angleDifference < 0) {
            desiredSpeed = 0;
        }
        // Dead zone management
        else if (Math.abs(angleDifference) < MaxAngleTolerance) {
            desiredSpeed = 0;
        }
        // If everything ok send command
        else {
            desiredSpeed = angleDifference * 5;
        }
        
        System.out.println("desiredSpeed" + desiredSpeed);
        allWheelAngleMotor.set(desiredSpeed);
        
        // Previous version (harder to manage limit switches and to understand)
//        if (currentAngle < requestedAngleValue){
//            if (currentAngle + MaxAngleTolerance > requestedAngleValue){
//                requestedAngleValue = currentAngle;
//                allWheelAngleMotor.set(0);
//            }
//            else if(currentAngle + MaxAngleTolerance < requestedAngleValue && anglePot.getAverageVoltage() < maxCanonAngleValue) {
//                allWheelAngleMotor.set(desiredSpeed);
//            }
//        }
//        if (currentAngle > requestedAngleValue){
//            if (currentAngle - MaxAngleTolerance < requestedAngleValue){
//                requestedAngleValue = currentAngle;
//                allWheelAngleMotor.set(0);
//            }
//            else if(currentAngle - MaxAngleTolerance > requestedAngleValue && anglePot.getAverageVoltage() > minCanonAngleValue) {
//                allWheelAngleMotor.set(desiredSpeed);
//            }
//        }
    }
    
    public void HandleAutoMode(){
        
                System.out.println(anglePot.getAverageVoltage() + "potentiometer value");

        
        // get the distance with the ultrasonic in order to set the right angle by itself
        
        currentDistance = (int)distanceUltrasonic.getAverageValue();
        
        angleCorrection = Robot.oi.getCoPilotJoystick().getRawAxis(4);
        
        //switch loop for different distances (will eventually use an algorithm after tests)
        
        switch (currentDistance){
            
            case 1:
                    {     
                requestedAngleValue = 1 + angleCorrection;
                break;
            }
            case 2:
            {
                requestedAngleValue = 2 + angleCorrection;
                break;
            }
            
            case 3:
            {
                requestedAngleValue = 3 + angleCorrection;
                break;
            }
            case 4:
            {
                requestedAngleValue = 4 + angleCorrection;
                break;
            }
            case 5:
            {
                requestedAngleValue = 5 + angleCorrection;
                break;
            }
            case 6:
            {
                requestedAngleValue = 6 + angleCorrection;
                break;
            }
            case 7:
            {
                requestedAngleValue = 7 + angleCorrection;
                break;
            }
            case 8:
            {
                requestedAngleValue = 8 + angleCorrection;
                break;
            }
            
        }
        
        // test if the canon can and needs to move, then move it (angle tolerance not added yet)
        
        if (requestedAngleValue > anglePot.getAverageVoltage() && anglePot.getAverageVoltage() < minCanonAngleValue){
            allWheelAngleMotor.set(1);
        }
        
        if (requestedAngleValue < anglePot.getAverageVoltage() && anglePot.getAverageVoltage() > minCanonAngleValue){
            allWheelAngleMotor.set(-1);
        }
    }
}
